# Cooperative Path Planners - README

## Overview
This program demonstrates cooperative multi-agent pathfinding using Space-Time A* algorithm. Two agents navigate through a maze generated by pymaze, avoiding collisions with each other while reaching their respective goals.

---

## AI Concepts Used

### 1. **A* Search Algorithm**
- **What it is**: A* is an informed search algorithm that finds the shortest path between two points
- **How it works**: Uses a heuristic function (Manhattan distance) to estimate the cost to reach the goal
- **Formula**: `f(n) = g(n) + h(n)`
  - `g(n)` = actual cost from start to current node
  - `h(n)` = estimated cost from current node to goal (heuristic)
  - `f(n)` = total estimated cost

### 2. **Space-Time A***
- **Extension of A***: Adds time dimension to the search space
- **State representation**: `(time, row, column)` instead of just `(row, column)`
- **Purpose**: Enables collision avoidance by reserving cells at specific time steps
- **Key feature**: Agents can "wait" at a position to avoid conflicts

### 3. **Cooperative Multi-Agent Planning**
- **Sequential planning**: Agent A plans first, then Agent B plans around A's path
- **Reservation system**: 
  - Cell reservations: Prevent agents from occupying the same cell at the same time
  - Edge reservations: Prevent agents from swapping positions (crossing paths)
- **Priority-based**: First agent gets priority, second agent must avoid

### 4. **Manhattan Distance Heuristic**
- **Definition**: `|x1 - x2| + |y1 - y2|`
- **Why used**: Admissible heuristic for grid-based movement (4-directional)
- **Property**: Never overestimates the actual distance, ensuring optimal paths

### 5. **Graph Search**
- **State space**: All possible positions in the maze at different time steps
- **Neighbors**: Adjacent cells (up, down, left, right) plus waiting action
- **Goal test**: Check if current position matches goal position

---

## Code Structure

### Main Components

#### 1. **neighbors(pos, m)**
```python
def neighbors(pos: Coord, m: maze) -> List[Coord]
```
- **Purpose**: Get valid neighboring cells from current position
- **Checks**: Uses pymaze's wall information (N, S, E, W directions)
- **Returns**: List of accessible neighbor coordinates

#### 2. **manhattan(a, b)**
```python
def manhattan(a: Coord, b: Coord) -> int
```
- **Purpose**: Calculate Manhattan distance between two points
- **Used as**: Heuristic function for A* algorithm
- **Ensures**: Optimal pathfinding in grid environments

#### 3. **astar_with_reservations()**
```python
def astar_with_reservations(start, goal, m, reserved, reserved_edges, max_time=200)
```
- **Core algorithm**: Space-Time A* implementation
- **Parameters**:
  - `start`, `goal`: Starting and ending positions
  - `m`: Pymaze maze object
  - `reserved`: Dictionary of reserved cells at each time step
  - `reserved_edges`: Dictionary of reserved edges (position swaps)
  - `max_time`: Maximum time steps to search
- **Returns**: List of positions representing the path

**Key Features**:
- Uses priority queue (heapq) for efficient node selection
- Tracks visited states to avoid reprocessing
- Implements collision avoidance through reservation checks
- Supports "waiting" action (staying at current position)

#### 4. **cooperative_planning()**
```python
def cooperative_planning(m: maze, startA, goalA, startB, goalB)
```
- **Purpose**: Plan paths for both agents cooperatively
- **Process**:
  1. Plan Agent A's path first (no restrictions)
  2. Reserve all cells and edges in Agent A's path
  3. Plan Agent B's path avoiding Agent A's reservations
  4. Pad paths to equal length for synchronized simulation
- **Returns**: Two paths of equal length

#### 5. **render_maze_terminal()**
```python
def render_maze_terminal(m, posA, posB, goalA, goalB, step)
```
- **Purpose**: Create ASCII visualization of maze with agents
- **Features**:
  - Draws walls using `+`, `-`, `|` characters
  - Shows agents: A (blue), B (red), @ (both at same position)
  - Shows goals: a (Agent A goal), b (Agent B goal)
  - Color-coded using ANSI escape codes

#### 6. **simulate_terminal()**
```python
def simulate_terminal(m, pathA, pathB, goalA, goalB, delay=0.3)
```
- **Purpose**: Animate the cooperative pathfinding step-by-step
- **Process**:
  1. Clear screen
  2. Render current state
  3. Wait for delay duration
  4. Move to next step
- **Shows**: Real-time movement of both agents

---

## How It Works

### Step-by-Step Execution

1. **Maze Generation**
   - Creates a 10x10 maze using pymaze library
   - Sets loop percentage to 30% (creates multiple paths)

2. **Define Start and Goal Positions**
   - Agent A: Bottom-right (10,10) → Top-left (1,1)
   - Agent B: Bottom-left (10,1) → Top-right (1,10)

3. **Plan Agent A's Path**
   - Run Space-Time A* without any restrictions
   - Find optimal path from start to goal

4. **Reserve Agent A's Path**
   - Mark all cells Agent A will occupy at each time step
   - Mark all edges (position transitions) Agent A will use
   - Extend reservation at goal position to prevent Agent B from blocking

5. **Plan Agent B's Path**
   - Run Space-Time A* with Agent A's reservations
   - Avoid all reserved cells and edges
   - May need to wait or take longer path to avoid collisions

6. **Synchronize Paths**
   - Pad shorter path by repeating final position
   - Ensures both agents move in lockstep during simulation

7. **Simulate Movement**
   - Display maze state at each time step
   - Show both agents moving simultaneously
   - Clear screen between frames for animation effect

---

## Key AI Techniques Explained

### Collision Avoidance

**Cell Reservation**:
```python
if nt in reserved and (nr, nc) in reserved[nt]:
    continue  # Skip this move, cell is occupied
```
- Prevents two agents from being at same position at same time

**Edge Reservation**:
```python
if t in reserved_edges and ((nr, nc), (r, c)) in reserved_edges[t]:
    continue  # Skip this move, would cause swap collision
```
- Prevents agents from swapping positions (crossing paths)

### Wait Action
```python
for nr, nc in neighbors((r, c), m) + [(r, c)]:  # Include current position
```
- Agent can stay at current position for one time step
- Allows temporal flexibility to avoid conflicts
- Essential for cooperative planning

### Priority Queue (Heap)
```python
heappush(open_heap, (f_score, tentative, state))
```
- Always explores most promising state first
- Ensures optimal path is found
- Efficient: O(log n) insertion and extraction

---

## Running the Program

### Requirements
```bash
pip install pyamaze
```

### Execution
```bash
python Cooperative_Path_Planners.py
```

### Expected Output
- Maze generation message
- Agent start and goal positions
- Path planning confirmation
- Step-by-step animated visualization
- Final statistics (path lengths)

---

## Customization Options

### Maze Size
```python
maze_size = 10  # Change to any size (e.g., 15, 20)
m = maze(maze_size, maze_size)
```

### Loop Percentage
```python
m.CreateMaze(loopPercent=30)  # Higher = more alternative paths
```

### Animation Speed
```python
simulate_terminal(m, pathA, pathB, goalA, goalB, delay=0.3)  # Adjust delay
```

### Start/Goal Positions
```python
startA = (maze_size, maze_size)  # Change as needed
goalA = (1, 1)
```

---

## Advantages of This Approach

1. **Guaranteed Collision-Free**: Reservation system ensures no conflicts
2. **Optimal for First Agent**: Agent A gets shortest possible path
3. **Complete**: Always finds solution if one exists
4. **Scalable**: Can extend to more than 2 agents (plan sequentially)
5. **Visual Feedback**: Terminal animation shows cooperative behavior

---

## Limitations

1. **Sequential Planning**: Later agents may get suboptimal paths
2. **Priority Matters**: First agent has advantage
3. **Computational Cost**: Space-Time A* is more expensive than regular A*
4. **Static Planning**: Paths are pre-computed, no dynamic replanning

---

## Learning Outcomes

By studying this code, you will understand:
- How A* search algorithm works
- Space-time planning for multi-agent systems
- Collision avoidance techniques
- Heuristic search methods
- Graph-based pathfinding
- Cooperative AI agent behavior
- Terminal-based visualization techniques

---

## Further Improvements

1. **Prioritized Planning**: Use better agent ordering strategies
2. **Conflict-Based Search (CBS)**: More sophisticated multi-agent planning
3. **Dynamic Replanning**: Handle moving obstacles
4. **Optimization**: Minimize total path length for all agents
5. **More Agents**: Extend to 3+ agents

---

## References

- A* Algorithm: Hart, P. E.; Nilsson, N. J.; Raphael, B. (1968)
- Space-Time A*: Silver, D. (2005) - Cooperative Pathfinding
- Multi-Agent Path Finding (MAPF): Stern et al. (2019)
